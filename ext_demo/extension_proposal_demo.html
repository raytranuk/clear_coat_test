<!DOCTYPE html>
<html>
<head>
    <title>WebGL EXT_shader_framebuffer_fetch extension proposal demo </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="icon" type="image/png" href="../playcanvas-favicon.png" />
    <script src="./playcanvas.js"></script>
    <style>
        body { 
            margin: 0;
            overflow-y: hidden;
        }
    </style>
</head>

<body>
    <!-- The canvas element -->
    <canvas id="application-canvas"></canvas>

    <!-- The script -->
    <script>
        var canvas = document.getElementById("application-canvas");
        // Create the app and start the update loop
        var app = new pc.Application(canvas, {
            mouse: new pc.Mouse(document.body),
            touch: new pc.TouchDevice(document.body),
            elementInput: new pc.ElementInput(canvas)
        });
    </script>

    <!-- Include some post effects -->
    <script src="./assets/scripts/posteffects/posteffect-outline.js"></script>

    <!-- The script -->
    <script>
        app.start();

        // Set the canvas to fill the window and automatically change resolution to be the same as the canvas size
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);

        app.scene.ambientLight = new pc.Color(0.2, 0.2, 0.2);

        // helper function to createa a primitive with shape type, position, scale, color and layer
        function createPrimitive(primitiveType, position, scale, color, layer) {
            // create material of specified color
            var material = new pc.StandardMaterial();
            material.diffuse = color;
            material.update();

            // create primitive
            var primitive = new pc.Entity();
            primitive.addComponent('model', {
                type: primitiveType,
                layers : layer
            });
            primitive.model.material = material;

            // set position and scale and add it to scene
            primitive.setLocalPosition(position);
            primitive.setLocalScale(scale);
            app.root.addChild(primitive);

            return primitive;
        }

        // create texture and render target for rendering into, including depth buffer
        var texture = new pc.Texture(this.app.graphicsDevice, {
            width: this.app.graphicsDevice.width,
            height: this.app.graphicsDevice.height,
            format: pc.PIXELFORMAT_R8_G8_B8_A8,
            autoMipmap: true,
            minFilter: pc.FILTER_LINEAR,
            magFilter: pc.FILTER_LINEAR
        });
        var renderTarget = new pc.RenderTarget(this.app.graphicsDevice, texture, { depth: true });

        // create a layer for rendering to texture, and add it to the beginning of layers to render into it first
        var outlineLayer = new pc.Layer({ name: "OutlineLayer" });
        app.scene.layers.insert(outlineLayer, 0);

        // set up layer to render to the render targer
        outlineLayer.renderTarget = renderTarget;

        // get world layer
        var worldLayer = app.scene.layers.getLayerByName("World");
        var UILayer = app.scene.layers.getLayerByName("UI");

        // create ground plane and 3 primitives, visible in both layers
        createPrimitive("plane", new pc.Vec3(0, 0, 0), new pc.Vec3(20, 20, 20), new pc.Color(0.3, 0.5, 0.3), [worldLayer.id]);
        createPrimitive("sphere", new pc.Vec3(-2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 0, 0), [worldLayer.id]);
        createPrimitive("box", new pc.Vec3(2, 1, 0), new pc.Vec3(2, 2, 2), new pc.Color(1, 1, 0), [worldLayer.id, outlineLayer.id]);
        createPrimitive("cone", new pc.Vec3(0, 1, -2), new pc.Vec3(2, 2, 2), new pc.Color(0, 1, 1), [worldLayer.id]);

        // Create main camera, which renders entities in world layer
        var camera = new pc.Entity();
        camera.addComponent("camera", {
            clearColor: new pc.Color(0.2, 0.2, 0.4),
            layers: [worldLayer.id, UILayer.id]
        });
        camera.translate(0, 20, 25);
        camera.lookAt(pc.Vec3.ZERO);

        // Create outline camera, which renders entities in outline layer
        var outlineCamera = new pc.Entity();
        outlineCamera.addComponent("camera", {
            clearColor: new pc.Color(0.0, 0.0, 0.0, 0.0),
            layers: [outlineLayer.id]
        });
        app.root.addChild(outlineCamera);

        var outline = new pc.OutlineEffect(app.graphicsDevice);
        outline.color = new pc.Color(0, 0, 1, 1);
        outline.texture = texture;
        var ppFlag=false;

        app.root.addChild(camera);

        // Create an Entity with a point light component and add it to both layers
        var light = new pc.Entity();
        light.addComponent("light", {
            type: "point",
            color: new pc.Color(1, 1, 1),
            range: 200,
            castShadows : true,
            layers: [worldLayer.id]
        });
        light.translate(0, 2, 5);
        app.root.addChild(light);

        //handle canvas resize
        window.addEventListener("resize", function () {
            app.resizeCanvas(canvas.width, canvas.height);

            if (ppFlag==true) camera.camera.postEffects.removeEffect(outline);

            app.scene.layers.remove(outlineLayer);

            texture.destroy();
            texture = new pc.Texture(this.app.graphicsDevice, {
                width: this.app.graphicsDevice.width,
                height: this.app.graphicsDevice.height,
                format: pc.PIXELFORMAT_R8_G8_B8_A8,
                autoMipmap: true,
                minFilter: pc.FILTER_LINEAR,
                magFilter: pc.FILTER_LINEAR
            });
            renderTarget.destroy();
            renderTarget = new pc.RenderTarget(this.app.graphicsDevice, texture, { depth: true });
            outlineLayer.renderTarget = renderTarget;

            app.scene.layers.insert(outlineLayer, 0);

            outline.texture = texture;

            if (ppFlag==true) camera.camera.postEffects.addEffect(outline);
        });

        // Offset position
        var localPosCurve = new pc.CurveSet([
            [0, 0, 1, 4],
            [0, 0, 1, 3],
            [0, 0, 1, 0]
        ]);
        localPosCurve.type = pc.CURVE_LINEAR;

        // make particles move in different directions
        var localVelocityCurve = new pc.CurveSet([
            [0, 0, 1, 8],
            [0, 0, 1, 6],
            [0, 0, 1, 0]
        ]);
        var localVelocityCurve2 = new pc.CurveSet([
            [0, 0, 1, -8],
            [0, 0, 1, -6],
            [0, 0, 1, 0]
        ]);

        // increasing gravity
        var worldVelocityCurve = new pc.CurveSet([
            [0, 0],
            [0, 0, 0.2, 6, 1, -48],
            [0, 0]
        ]);

        // gradually make sparks bigger
        var scaleCurve = new pc.Curve(
            [0, 0, 0.5, 0.3, 0.8, 0.2, 1, 0.1]
        );

        var scaleCurve2 = new pc.Curve(
            [0, 0, 0.5, 0.5, 0.8, 0.8, 1, 1]
        );

        // rotate sparks 360 degrees per second
        var angleCurve = new pc.Curve(
            [0, 360]
        );

        // color changes throughout lifetime
        var colorCurve = new pc.CurveSet([
            [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0],
            [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],            
            [0, 0, 1, 0]
        ]);

        var colorCurve2 = new pc.CurveSet([
            [0, 0, 1, 0],
            [0, 0, 0.125, 0.25, 0.25, 0.5, 0.375, 0.75, 0.5, 1],
            [0, 1, 0.25, 1, 0.375, 0.5, 0.5, 0]
        ]);        

        // Create entity for particle system
        var particles = new pc.Entity();
        app.root.addChild(particles);
        particles.setLocalPosition(0, 1, 0);

        var particles2 = new pc.Entity();
        app.root.addChild(particles2);
        particles2.setLocalPosition(0, 1, 0);

        //preload this?
        app.assets.loadFromUrl('./assets/fonts/Arial-v4/ArialA.png', 'texture', function (err, asset) {});

        // load spark texture
        app.assets.loadFromUrl('./assets/textures/spark.png', 'texture', function (err, asset) {

            // when texture is loaded add particlesystem component to entity
            particles.addComponent("particlesystem", {
                numParticles: 200,
                lifetime: 2,
                rate: 0.01,
                scaleGraph: scaleCurve,
                rotationSpeedGraph: angleCurve,
                colorGraph: colorCurve,
                colorMap: asset.resource,
                velocityGraph: worldVelocityCurve,
                localVelocityGraph: localVelocityCurve,
                localVelocityGraph2: localVelocityCurve2,
                blendType: pc.BLEND_NORMAL,
                layers : [worldLayer.id]
            });

            particles2.addComponent("particlesystem", {
                numParticles: 200,
                lifetime: 2,
                rate: 0.01,
                scaleGraph: scaleCurve,
                rotationSpeedGraph: angleCurve,
                colorGraph: colorCurve,
                colorMap: asset.resource,
                velocityGraph: worldVelocityCurve,
                localVelocityGraph: localVelocityCurve,
                localVelocityGraph2: localVelocityCurve2,
                blendType: pc.BLEND_ADDITIVE,
                layers : [worldLayer.id]
            });   
            
            particles2.particlesystem.emitter.seed=particles.particlesystem.emitter.seed;

            particles.enabled = false;
            particles2.enabled = false;
        });

        // Create a 2D screen
        var screen = new pc.Entity();
        screen.addComponent("screen", {
            referenceResolution: new pc.Vec2(1280, 720),
            scaleBlend: 0.5,
            scaleMode: pc.SCALEMODE_BLEND,
            screenSpace: true
        });
        app.root.addChild(screen);

        var loremIpsum = "This demo shows post process effects... particle effects... and text rendering effects... that are commonly used in 3D apps & games, and that would render more efficiently on tile-based GPUs if WebGL added support for the existing OpenGL ES extension: EXT_shader_framebuffer_fetch";
        var text = new pc.Entity();
        text.addComponent("element", {
            anchor: [ 0.5, 0.9, 0.5, 0.9 ],
            autoWidth: false,
            fontSize: 32,
            pivot: [ 0.5, 1.0 ],
            text: loremIpsum,
            type: pc.ELEMENTTYPE_TEXT,
            width: 640,
            wrapLines: true
        });
        screen.addChild(text);

        var typeStep=1;
        var demoStage=0;

        // Load a font
        var fontAsset = new pc.Asset('courier.json', "font", {url: "./assets/fonts/courier.json"});
        fontAsset.on('load', function () {
            // Apply the font to the text element
            text.element.fontAsset = fontAsset;

            // Start with no text printed
            text.element.rangeStart = 0;
            text.element.rangeEnd = 0;

            // Render a new character every 100ms
            setInterval(function () {
                text.element.rangeEnd += typeStep;
                if (demoStage==4 && typeStep>0)
                {
                    //typeStep = 0;
                    text.element.rangeEnd = 0; 
                    demoStage = 0; 
                } 
                else if (demoStage==3 && text.element.rangeEnd >= loremIpsum.length)
                {
                    typeStep = 0;
                    demoStage = 4; 
                }              
                else if (demoStage==2 && text.element.rangeEnd >= 90) 
                {
                    typeStep = 0;
                    demoStage = 3; //text
                }
                else if (demoStage==1 && text.element.rangeEnd >= 60) 
                {
                    typeStep = 0;
                    demoStage = 2; //particles
                }                           
                else if (demoStage==0 && text.element.rangeEnd >= 40) 
                {
                    typeStep = 0; //pause for post effects
                    demoStage = 1;
                }
            }, 30);
        });

        // Create a text element a thicker font outline enabled
        var text2 = new pc.Entity();
        text2.addComponent("element", {
            anchor: [ 0.5, 0.4, 0.5, 0.4 ],
            autoWidth: false,
            color: new pc.Color(0.75, 0.75, 0.95),
            opacity: 0.6,
            fontSize: 96,
            outlineColor: new pc.Color(0.1, 0.1, 0.2, 0.6),
            outlineThickness: 5.0,
            shadowColor: new pc.Color(0, 0, 0.1, 0.3),
            shadowOffset: new pc.Vec2(0.95, -0.95),            
            pivot: [ 0.5, 0.5 ],
            text: "EXT shader framebuffer fetch",
            type: pc.ELEMENTTYPE_TEXT,
            width: 512,
            wrapLines: true
        });
        screen.addChild(text2);
        
        var typeStep2=0;

        // Load fonts
        var fontAsset2 = new pc.Asset('Arial.json', "font", {url: "./assets/fonts/Arial-v4/Arial.json"});
        fontAsset2.on('load', function () {
            // Apply the font to the text element
            text2.element.fontAsset = fontAsset2;

            // Start with no text printed
            text2.element.rangeStart = 0;
            text2.element.rangeEnd = 0;

            // Render a new character every 100ms
            setInterval(function () {
                if (typeStep2==0)
                {
                    text2.element.rangeEnd = 0;
                    text2.enabled=false;
                }
                else
                {
                    text2.element.rangeEnd += typeStep2;
                    text2.enabled=true;
                }
                if (text2.element.rangeEnd >= text2.element.text.length) {
                    text2.element.rangeEnd = text2.element.text.length;
                }
            }, 30);            
        });

        app.assets.add(fontAsset);
        app.assets.add(fontAsset2);        
        app.assets.load(fontAsset);
        app.assets.load(fontAsset2);        

        function createButton(px,py,pz,labelText) {
            // Create a simple button
            var button = new pc.Entity();
            button.addComponent("button", {
                imageEntity: button
            });
            button.addComponent("element", {
                anchor: [ px, py, px, py ],
                height: 40,
                pivot: [ 0.5, 0.5 ],
                type: pc.ELEMENTTYPE_IMAGE,
                width: 200,
                useInput: true
            });
            screen.addChild(button);

            // Create a label for the button
            var label = new pc.Entity();
            label.addComponent("element", {
                anchor: [ 0.5, 0.5, 0.5, 0.5 ],
                color: new pc.Color(0, 0, 0),
                fontSize: 24,
                height: 64,
                pivot: [ 0.5, 0.5 ],
                text: labelText,
                type: pc.ELEMENTTYPE_TEXT,
                width: 128,
                wrapLines: true
            });
            button.addChild(label);

            label.element.fontAsset = fontAsset2;

            return button;
        }

        var stageTime = 0;
        var time = 0;

        var button1=createButton(0.2,0.1,0,"POSTPROCESS");
        var button2=createButton(0.5,0.1,0,"TEXT");
        var button3=createButton(0.8,0.1,0,"PARTICLES");

       // Change the background color every time the button is clicked
       button1.button.on('click', function (e) {
            typeStep2=0;
            particles.enabled = false;
            particles2.enabled = false;            
            if (ppFlag!=true) camera.camera.postEffects.addEffect(outline);
            ppFlag=true;        
            stageTime=time+15.0;
            text.enabled=true;
            text.element.rangeStart = loremIpsum.length-28;
            text.element.rangeEnd = loremIpsum.length;
        });

        button2.button.on('click', function (e) {
            particles.enabled = false;
            particles2.enabled = false;
            if (ppFlag==true) camera.camera.postEffects.removeEffect(outline);
            ppFlag=false; 
            typeStep2=1;          
            text2.element.outlineThickness=5.0;
            stageTime=time+15.0;  
            text.enabled=false;
            //text.element.rangeStart = loremIpsum.length-28;    
        });        

        button3.button.on('click', function (e) {
            if (ppFlag==true) camera.camera.postEffects.removeEffect(outline);
            ppFlag=false;  
            typeStep2=0;          
            particles.enabled = true;
            particles2.enabled = true;
            stageTime=time+15.0;
            text.enabled=true;
            text.element.rangeStart = loremIpsum.length-28;
            text.element.rangeEnd = loremIpsum.length;
        }); 

        //button1.enabled=false;
        //button2.enabled=false;
        //button3.enabled=false;

        // update things each frame
        app.on("update", function (dt) {
            // rotate cameras around the objects
            time += dt;
            camera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));
            camera.lookAt(pc.Vec3.ZERO);
            outlineCamera.setLocalPosition(12 * Math.sin(time), 5, 12 * Math.cos(time));
            outlineCamera.lookAt(pc.Vec3.ZERO);

            if (typeStep==0)
            {
                if (stageTime==0)
                {   
                    if (demoStage==1)
                    {
                        stageTime=time+4.0;
                        if (ppFlag==false) camera.camera.postEffects.addEffect(outline);
                        ppFlag=true;
                    }
                    else if (demoStage==2)
                    {
                        stageTime=time+4.0;
                        particles.enabled = true;
                        particles2.enabled = true;
                    }
                    else if (demoStage==3)
                    {
                        stageTime=time+4.0;
                        typeStep2=1;
                    }          
                    else if (demoStage==4)
                    {
                        stageTime=time+15.0;
                    }                      
                }
                else if (stageTime>time)
                {
                    if (ppFlag==true)
                    {
                        outline.color.set((Math.sin(time*16.0)+1.0)*0.5, 0, 0, 1);
                    }
                    if (demoStage==4)
                    {    
                        if (button1.enabled==false && (stageTime-time)<11.0)
                        {
                            text.element.rangeStart = loremIpsum.length-28;
                            text.element.rangeEnd = loremIpsum.length;
                            //typeStep2=1;
                            //button1.enabled=true;
                            //button2.enabled=true;
                            //button3.enabled=true;
                        }

                        if (typeStep2)
                        {
                            text2.element.outlineThickness=((Math.cos((15.0-(stageTime-time))*2)+1)*0.4+0.2)*5.0;
                        }
                    }
                }
                else
                {
                    stageTime=0;
                    if (demoStage==1)
                    {                    
                        if (ppFlag==true) camera.camera.postEffects.removeEffect(outline);
                        ppFlag=false;
                        typeStep=1;
                    }   
                    else if (demoStage==2)
                    {
                        particles.enabled = false;
                        particles2.enabled = false;
                        typeStep=1;
                    }      
                    else if (demoStage==3)
                    {
                        typeStep2=0;
                        typeStep=1;
                    }
                    else if (demoStage==4)
                    {
                        if (ppFlag==true) camera.camera.postEffects.removeEffect(outline);
                        ppFlag=false;
                        particles.enabled = false;
                        particles2.enabled = false;
                        text2.element.outlineThickness=5.0;
                        typeStep2=0;
                        //button1.enabled=false;
                        //button2.enabled=false;
                        //button3.enabled=false;                        
                        typeStep=1;
                        text.enabled=true;
                        text.element.rangeStart = 0;
                        text.element.rangeEnd = 0;
                    }                                                             
                }
            }
        });
    </script>
</body>
</html>
